-- ==[ BLACKAIR AUTO FARM - BEREINIGTE VERSION ]==

-- dbg helper
local function dbg(msg)
    print("[BLACKAIR DEBUG]: " .. tostring(msg))
end

-- loader queuing (falls supported)
local url = 'https://raw.githubusercontent.com/TeamB-dot/XAUHIfhioasuhfgaioshugiaosghuisaihougsaiouhguiohasghiouashuigoasiouhgasiouhgihuo/refs/heads/main/loader'
local success, response = pcall(function() return game:HttpGet(url) end)
if success and response then
    if syn and syn.queue_on_teleport then
        syn.queue_on_teleport("loadstring(game:HttpGet('"..url.."'))()")
    elseif queue_on_teleport then
        queue_on_teleport("loadstring(game:HttpGet('"..url.."'))()")
    else
        dbg("queue_on_teleport | Your Executor Does Not Support Auto Farm System.")
    end
else
    dbg("Error loading code or remote loader unavailable.")
end

-- wait for load
local Time = 1
repeat task.wait() until game:IsLoaded()
task.wait(Time)

-- services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- globals & state
local PlaceID = game.PlaceId
local AllIDs = {}
local foundAnything = ""
local actualHour = os.date("!*t").hour
local Deleted = false

-- TPReturner (Server list + pick logic)
function TPReturner()
    local ok, Site = pcall(function()
        if foundAnything == "" then
            return HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
        else
            return HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
        end
    end)

    if not ok or not Site then
        dbg("TPReturner: Fehler beim Abrufen der Serverliste")
        return
    end

    if Site.nextPageCursor and Site.nextPageCursor ~= "null" then
        foundAnything = Site.nextPageCursor
    end

    local Servers = {}
    for _, v in pairs(Site.data) do
        if tonumber(v.maxPlayers) > tonumber(v.playing) then
            table.insert(Servers, v)
        end
    end

    table.sort(Servers, function(a, b)
        return a.playing > b.playing
    end)

    for _, v in ipairs(Servers) do
        local ID = tostring(v.id)
        local Possible = true
        for _, Existing in pairs(AllIDs) do
            if ID == tostring(Existing) then
                Possible = false
                break
            end
        end

        if Possible then
            local playerRatio = v.playing / v.maxPlayers
            if playerRatio > 0.75 or math.random() < 0.1 then
                table.insert(AllIDs, ID)
                pcall(function()
                    if writefile then
                        writefile("NotSameServers_BLACKAIR.json", HttpService:JSONEncode(AllIDs))
                    end
                    task.wait()
                    game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
                end)
                task.wait(4)
                break
            end
        end
    end
end

-- ===== UI (Watermark etc.) - unverÃ¤ndert, nur robust gemacht =====
local playerGui = player:WaitForChild("PlayerGui")

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "WatermarkGui"
screenGui.IgnoreGuiInset = true
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

local uiScale = Instance.new("UIScale", screenGui)
local function adjustScale()
	local size = workspace.CurrentCamera.ViewportSize
	uiScale.Scale = size.X < 1000 and 0.75 or 1
end
adjustScale()
RunService.Heartbeat:Connect(adjustScale)

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 450, 0, 60)
frame.Position = UDim2.new(0.5, -225, 0, 90)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
frame.BackgroundTransparency = 0.2
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = screenGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0.15, 0)
corner.Parent = frame

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(15, 15, 15)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(40, 40, 40))
}
gradient.Rotation = 90
gradient.Parent = frame

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, -20, 1, -20)
label.Position = UDim2.new(0, 10, 0, 10)
label.BackgroundTransparency = 1
label.Text = "BlackAir Auto Farm"
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.TextSize = 28
label.Font = Enum.Font.GothamBlack
label.TextStrokeTransparency = 0.65
label.TextScaled = true
label.Parent = frame

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(1, -20, 0, 18)
fpsLabel.Position = UDim2.new(0, 10, 1, -22)
fpsLabel.BackgroundTransparency = 1
fpsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
fpsLabel.TextSize = 14
fpsLabel.Font = Enum.Font.Gotham
fpsLabel.TextXAlignment = Enum.TextXAlignment.Right
fpsLabel.Text = "FPS: ..."
fpsLabel.Parent = frame

local glow = Instance.new("ImageLabel")
glow.Name = "Glow"
glow.Size = UDim2.new(1, 8, 1, 8)
glow.Position = UDim2.new(0, -4, 0, -4)
glow.BackgroundTransparency = 1
glow.Image = "rbxassetid://5028857084"
glow.ImageColor3 = Color3.fromRGB(0, 200, 255)
glow.ImageTransparency = 0.85
glow.ZIndex = frame.ZIndex - 1
glow.Parent = frame

local particleFrame = Instance.new("Frame")
particleFrame.Size = UDim2.new(1, 0, 1, 0)
particleFrame.BackgroundTransparency = 1
particleFrame.ClipsDescendants = true
particleFrame.Parent = frame

local function createParticle()
	local p = Instance.new("Frame")
	p.Size = UDim2.new(0, math.random(6, 12), 0, math.random(6, 12))
	p.Position = UDim2.new(math.random(), 0, 1, 0)
	p.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	p.BackgroundTransparency = 0.85
	p.ZIndex = 5
	p.Parent = particleFrame

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(1, 0)
	corner.Parent = p

	local targetPos = UDim2.new(p.Position.X.Scale, 0, -0.2, 0)
	local t = TweenService:Create(p, TweenInfo.new(math.random(3, 6), Enum.EasingStyle.Linear), {Position = targetPos})
	t:Play()
	t.Completed:Connect(function() p:Destroy() end)
end

task.spawn(function()
	while true do
		createParticle()
		task.wait(0.2)
	end
end)

local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://17582299860"
sound.Volume = 1
sound.Parent = screenGui
pcall(function() sound:Play() end)

local function show()
	label.TextTransparency = 1
	frame.Visible = true
	glow.ImageTransparency = 1

    local slide = TweenService:Create(frame, TweenInfo.new(0.8, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, -225, 0, 100)})
	local fade = TweenService:Create(label, TweenInfo.new(1, Enum.EasingStyle.Quad), {TextTransparency = 0})
	local glowIn = TweenService:Create(glow, TweenInfo.new(1), {ImageTransparency = 0.85})

	slide:Play()
	fade:Play()
	glowIn:Play()

	fade.Completed:Wait()
end

RunService.RenderStepped:Connect(function()
    local ok, fps = pcall(function() return math.floor(1 / RunService.RenderStepped:Wait()) end)
    if ok then fpsLabel.Text = "FPS: " .. tostring(fps) end
end)

-- IDENTIFIER STORAGE (safety)
local BridgeNet = nil
local identifierStorage = nil
pcall(function()
    BridgeNet = ReplicatedStorage:WaitForChild("BridgeNet2")
    identifierStorage = BridgeNet:WaitForChild("identifierStorage")
end)

-- helper debug wrapper
function debug(msg)
    dbg(msg)
end

-- VEHICLE / CAR functions (unchanged mostly)
function findPlayerCar()
    for _, vehicle in pairs(workspace:WaitForChild("Vehicles"):GetChildren()) do
        if vehicle.Name == "Orange" then continue end
        local info = vehicle:FindFirstChild("InfoFolder")
        if info and info:FindFirstChild("Owner") and tostring(info.Owner.Value):lower() == player.Name:lower() then
            debug("Sigma car : " .. vehicle.Name)
            return vehicle
        end
    end
    debug("car not found")
    return nil
end

function unlockVehicle(car)
    pcall(function()
        if ReplicatedStorage and ReplicatedStorage.Client and ReplicatedStorage.Client.Communication and ReplicatedStorage.Client.Communication.LockVehicle then
            ReplicatedStorage.Client.Communication.LockVehicle:InvokeServer(car, false)
            debug("Car unlocked")
        end
    end)
end

function sitInCar(car)
    if not car then return end
    local seat = car:FindFirstChild("Seats") and car.Seats:FindFirstChild("Seat1")
    if not seat then debug("Seat not found!") return end
    local byte = identifierStorage and identifierStorage:GetAttribute("RemoteEvent_OnSitVehicleSeat")
    if not byte then debug("SitByte error!") return end

    local args = {
        {
            {
                KevArgs = { car, seat }
            },
            byte
        }
    }
    pcall(function() BridgeNet.dataRemoteEvent:FireServer(unpack(args)) end)

    local start = os.clock()
    while os.clock() - start < 5 do
        if seat.Occupant and seat.Occupant.Parent == player.Character then break end
        task.wait(0.1)
    end
    debug("Player In Car")
end

function teleportCarToCoordinates(car, pos)
    if not car then return end
    for _, part in pairs(car:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = true end end
    car:PivotTo(CFrame.new(pos + Vector3.new(0, 300, 0)))
    task.wait(0.2)
    car:PivotTo(CFrame.new(pos + Vector3.new(0, 300, 0)))
    task.wait(0.2)
    car:PivotTo(CFrame.new(pos))
    task.wait(0.2)
    for _, part in pairs(car:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = false end end
    debug("Car TP to POS")
end

function teleportCarCloseToPlayer(car)
    if not car then return end
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then debug("no HRP found!") return end
    local target = root.Position + root.CFrame.LookVector * 5
    for _, part in pairs(car:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = true end end
    car:PivotTo(CFrame.new(target))
    task.wait(0.1)
    for _, part in pairs(car:GetDescendants()) do if part:IsA("BasePart") then part.Anchored = false end end
end

function exitCar(customTP)
    local exitByte = identifierStorage and identifierStorage:GetAttribute("RemoteEvent_VehicleInteraction")
    if not exitByte then return end

    local args = {
        {
            {
                KevArgs = { [1] = 6 }
            },
            exitByte
        }
    }
    pcall(function() BridgeNet.dataRemoteEvent:FireServer(unpack(args)) end)

    if customTP then
        task.delay(1, function()
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if root then root.CFrame = CFrame.new(customTP) end
        end)
    end
end

function renameATMs()
    local atmFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shop_Rob") and workspace.Map.Shop_Rob:FindFirstChild("InkasseBank")
    if not atmFolder then return 0 end
    local count = 0
    for _, model in ipairs(atmFolder:GetChildren()) do
        if model:IsA("Model") and model.Name:sub(1,3) == "ATM" and model:FindFirstChild("Main") then
            model.Name = "ATM" .. tostring(count + 1)
            count = count + 1
            debug("ATM Rename: " .. model.Name)
        end
    end
    return count
end

function checkATMsBeforeExit()
    local atmFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shop_Rob") and workspace.Map.Shop_Rob:FindFirstChild("InkasseBank")
    if not atmFolder then return false end
    local brokenCount = 0
    local totalATM = 0
    for _, model in ipairs(atmFolder:GetChildren()) do
        if model:IsA("Model") and model.Name:find("ATM") and model:FindFirstChild("Main") then
            totalATM = totalATM + 1
            if model:GetAttribute("Destroyed") == true then
                brokenCount = brokenCount + 1
                debug(model.Name .. " = Destroyed")
            else
                debug(model.Name .. " = Intakt")
            end
        end
    end
    if totalATM > 0 and brokenCount == totalATM then
        debug("Alle ATMs zerstÃ¶rt, Bank wird Ã¼bersprungen.")
        return true
    end
    return false
end

-- ===== WEBHOOK & FORMAT HELPERS =====
local webhookUrl = "https://discord.com/api/webhooks/1417219625577615501/MeN7r39hMSpALWRndNHim3RD6gSqLaMRlWZkI3S3uh4HJyDc_ZJfIYpcOPMV5ypm0-e5" -- <<== HIER DEIN WEBHOOK EINFÃGEN
local function formatNumber(num)
    local n = tonumber(num) or 0
    local formatted = tostring(math.floor(n))
    local k
    while true do
        formatted, k = formatted:gsub("^(-?%d+)(%d%d%d)", '%1,%2')
        if k == 0 then break end
    end
    return formatted
end

local function getRequestFunction()
    return (syn and syn.request) or http_request or request or (fluxus and fluxus.request)
end

local function sendToDiscord(amount, reachedMax)
    local username = player and player.Name or "Unknown"
    local timeNow = os.date("%d.%m.%Y %H:%M:%S")
    local formattedMoney = formatNumber(amount) .. " $"
    local title = reachedMax and "ð¨ 1.000.000 erreicht!" or "ð° Money Bot Farm"
    local desc = "**Bot:** " .. username .. "\n" ..
                 "**Money:** " .. formattedMoney .. "\n" ..
                 "**German Time:** " .. timeNow
    local data = {
        ["username"] = "Robbery Logger",
        ["embeds"] = {{
            ["title"] = title,
            ["description"] = desc,
            ["color"] = reachedMax and 16711680 or 65280
        }}
    }
    local jsonData = HttpService:JSONEncode(data)
    local requestFunction = getRequestFunction()
    if requestFunction then
        local ok, res = pcall(function()
            return requestFunction({
                Url = webhookUrl,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = jsonData
            })
        end)
        if ok then
            dbg("[Webhook] gesendet: " .. formattedMoney .. " | " .. username)
        else
            warn("[Webhook] fehler: " .. tostring(res))
        end
    else
        warn("[Webhook] Kein kompatibler Request-Handler gefunden!")
    end
end

function checkAndEquipCashOutItem()
    if _G and _G.StopFarm then return end

    local Backpack = player:FindFirstChild("Backpack")
    if not Backpack then return end

    for _, item in ipairs(Backpack:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("OnCashOut") then
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:EquipTool(item)
            end

            warn("[Farm] ð¼ Money Bag gefunden:", item.Name)
            task.wait(0.5)

            -- â Remote sofort zerstÃ¶ren, damit kein Local CashOut mÃ¶glich ist
            local remote = item:FindFirstChild("OnCashOut")
            if remote then
                pcall(function() remote:Destroy() end)
                warn("[Farm] ð OnCashOut Remote zerstÃ¶rt, kein Local Cash mehr mÃ¶glich.")
            end

            -- DirtyMoney Wert prÃ¼fen
            local dirtyMoney = item:GetAttribute("DirtyMoney")
            if dirtyMoney then
                warn("[Farm] ðµ DirtyMoney erkannt:", dirtyMoney)
                sendToDiscord(dirtyMoney)

                if tonumber(dirtyMoney) >= 1000000 then
                    _G.StopFarm = true
                    _G.ShouldLeave = true
                    sendToDiscord(dirtyMoney, true)
                    warn("ð¨ Limit erreicht! Bot wird am Ende leaven statt serverhop.")
                end
            else
                warn("[Farm] â Kein DirtyMoney-Attribut gefunden")
            end

            break
        end
    end
end

-- ===== ATM / ROB / COLLECT =====
function destroyATMs(count)
    local byte = identifierStorage and identifierStorage:GetAttribute("RemoteEvent_OnMellee")
    if not byte then debug("MeleeByte Error") return end
    for i = 1, count do
        local atm = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shop_Rob") and workspace.Map.Shop_Rob:FindFirstChild("InkasseBank") and workspace.Map.Shop_Rob.InkasseBank:FindFirstChild("ATM"..tostring(i))
        if atm and atm:FindFirstChild("Main") then
            local args = {
                {
                    {
                        KevArgs = {
                            {
                                {
                                    HitType = 3,
                                    Model = atm,
                                    Hit = atm.Main
                                }
                            },
                            3
                        }
                    },
                    byte
                }
            }
            pcall(function() BridgeNet.dataRemoteEvent:FireServer(unpack(args)) end)
            debug("ZerstÃ¶re ATM" .. tostring(i))
            task.wait(0.5)
        end
    end
end

function collectCash()
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then debug("no HRP!") return end
    local collected = 0
    for _, mesh in ipairs(workspace:FindFirstChild("Ignore") and workspace.Ignore:GetDescendants() or {}) do
        if mesh:IsA("MeshPart") and (mesh.Position - root.Position).Magnitude <= 45 then
            local prompt = mesh:FindFirstChildOfClass("ProximityPrompt")
            if prompt then
                prompt.HoldDuration = 0
                mesh.Anchored = true
                mesh.CFrame = CFrame.new(root.Position - Vector3.new(0,2,0))
                for _ = 1, 200 do
                    pcall(function() fireproximityprompt(prompt, 0) end)
                end
                collected = collected + 1
            end
        end
    end
    debug("Cash eingesammelt: " .. tostring(collected))
end

-- TANKS
local tankstellen = {
    { name = "Tankstelle3", carTP = Vector3.new(-632.56,44.06,2430.84), playerTP = Vector3.new(-636.01,44.11,2474.99) },
    { name = "Tankstelle4", carTP = Vector3.new(-1238.83,44.06,2132.27), playerTP = Vector3.new(-1237.77,44.11,2089.23) },
}

function robTankstelle(tankInfo, car)
    debug("Starte Tankstellenraub: " .. tostring(tankInfo.name))
    teleportCarToCoordinates(car, tankInfo.carTP)
    task.wait(1)
    local tankModel
    local timeout = os.clock() + 6
    while not tankModel and os.clock() < timeout do
        tankModel = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Shop_Rob") and workspace.Map.Shop_Rob:FindFirstChild(tankInfo.name)
        task.wait(0.2)
    end
    if not tankModel then warn("Tankstelle konnte nicht geladen werden: " .. tostring(tankInfo.name)); return false end
    local dummy = tankModel:FindFirstChild("Dummy")
    if not dummy then warn("Dummy fehlt bei: " .. tostring(tankInfo.name)); return false end
    if dummy:GetAttribute("IsBedroht") == true then debug(tankInfo.name .. " wurde bereits ausgeraubt. Ãberspringe."); return false end
    exitCar()
    task.wait(1)
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if root then root.CFrame = CFrame.new(tankInfo.playerTP); task.wait(0.5) end
    local remote = dummy:FindFirstChild("OnRob")
    if not remote then warn("Remote fehlt bei Dummy"); return false end
    debug("Spamme Remote bis Tankstelle bedroht ist...")
    local robTimeout = os.clock() + 10
    while not dummy:GetAttribute("IsBedroht") and os.clock() < robTimeout do
        pcall(function() remote:FireServer() end)
        task.wait(0.1)
    end
    if dummy:GetAttribute("IsBedroht") then
        debug("Tankstelle bedroht! Warte auf Geld...")
        while not dummy:GetAttribute("IsBedroht") do task.wait(0.1) end
        task.wait(1)
        collectCash()
        return true
    else
        warn("Tankstellenraub fehlgeschlagen (kein IsBedroht)")
        return false
    end
end

-- ===== SERVERHOP / TELEPORT (nur 1 Definition!) =====
_G.StopFarm = false
_G.ShouldLeave = false

function Teleport()
    while task.wait() do
        if _G.StopFarm then
            if _G.ShouldLeave then
                warn("ð¨ Bot verlÃ¤sst das Spiel (1 Mio erreicht) - Kick wird ausgelÃ¶st")
                -- kurze VerzÃ¶gerung, Webhook schon vorher gesendet
                task.wait(1.5)
                pcall(function() player:Kick("ð¨ Bot hat 1.000.000 $ erreicht â") end)
                break
            else
                warn("â Serverhop gestoppt durch Stop-Flag")
                break
            end
        end
        pcall(function()
            TPReturner()
            if foundAnything ~= "" then
                TPReturner()
            end
        end)
    end
end

-- ===== SCRIPT START (Flow) =====
local car = findPlayerCar()
if not car then
    dbg("Kein Auto gefunden - Script beendet")
    return
end

unlockVehicle(car)
task.wait(0.2)
teleportCarCloseToPlayer(car)
task.wait(0.2)
sitInCar(car)

-- check & equip money bag (setzt Flags falls >= 1.000.000)
checkAndEquipCashOutItem()
task.wait(0.5)

teleportCarToCoordinates(car, Vector3.new(-404.33,44.61,-204.47))
task.wait(0.2)

local bankAlreadyRobbed = checkATMsBeforeExit()
if not bankAlreadyRobbed then
    exitCar(Vector3.new(-382.76,45.39,-234.59))
    task.wait(1.2)
    local atmCount = renameATMs()
    task.wait(0.3)
    destroyATMs(atmCount)
    task.wait(0.3)
    collectCash()
    debug("Bankraub abgeschlossen")
else
    debug("Bank wird Ã¼bersprungen (bereits ausgeraubt)")
end

for _, tank in ipairs(tankstellen) do
    debug("Teleportiere vorab zur Tankstelle: " .. tostring(tank.name))
    sitInCar(car)
    task.wait(0.5)
    robTankstelle(tank, car)
    task.wait(0.5)
end

-- Finale RÃ¼ck-Teleport (falls kein Stop gesetzt, Teleport wird loop starten)
sitInCar(car)
teleportCarToCoordinates(car, Vector3.new(-18.68,-224.36,-234.48))
task.wait(2)

-- Starte Teleport/Serverhop loop (wird sehen ob StopFarm/ShouldLeave gesetzt wurde)
Teleport()
